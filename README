# SenderEmail — Microservicio de envío de correos (Gmail SMTP + Spring Boot)

Servicio REST para envío de emails mediante **Gmail SMTP**. Incluye buenas prácticas de arquitectura, manejo de errores JSON uniforme, lineamientos para **mTLS entre Gateway y microservicio**, y opción de proteger por **OAuth2 (PKCE)** a nivel de Gateway.

---

## 🚀 Stack

* **Java 17**
* **Spring Boot 3.5.x**
* `spring-boot-starter-web`
* `spring-boot-starter-mail`
* *(opcional)* `spring-boot-starter-oauth2-resource-server`
* **Maven**

---

## 📁 Estructura recomendada

```
src/main/java/com/email/sendemail/
  controller/
    EmailController.java
  dto/
    EmailRequest.java
    ApiResponse.java
  exception/
    EmailSendException.java
    GlobalExceptionHandler.java
  service/
    EmailService.java
resources/
  application.properties
  (opcional) certs/       # *.p12 para mTLS (NO commitear)
```

---

## 🔐 Requisitos de Gmail (SMTP)

1. **Activa 2FA** en la cuenta.
2. **Crea una App Password** para “Correo”.
3. **Usa la clave de 16 caracteres sin espacios** (ej.: `abcdefghijklmnop`).

> Importante: No uses la contraseña normal de Gmail; siempre **App Password**.

---

## ⚙️ Configuración

### `application.properties` (mínimo)

```properties
server.port=8080

# Gmail SMTP
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=${MAIL_USERNAME}
spring.mail.password=${MAIL_PASSWORD}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.default-encoding=UTF-8
```

### Variables de entorno (recomendado en PROD)

| Variable                 | Requerida | Ejemplo               | Descripción           |
| ------------------------ | --------- | --------------------- | --------------------- |
| `MAIL_USERNAME`          | ✅         | `tu_cuenta@gmail.com` | Cuenta de envío       |
| `MAIL_PASSWORD`          | ✅         | `abcdefghijklmnop`    | App Password de Gmail |
| `SERVER_PORT`            | ❌         | `8080`                | Puerto del servicio   |
| `SPRING_PROFILES_ACTIVE` | ❌         | `prod`                | Perfil de ejecución   |

> Mantén los secretos en variables de entorno o un vault. **No** los hardcodees ni los commitees.

### `.env.example`

```
MAIL_USERNAME=tu_cuenta@gmail.com
MAIL_PASSWORD=abcdefghijklmnop
SERVER_PORT=8080
SPRING_PROFILES_ACTIVE=dev
```

---

## 🧩 API

### POST `/api/email/send`

**Descripción:** Enviar correo de texto plano.

**Request Body**

```json
{
  "to": "destinatario@dominio.com",
  "subject": "Asunto de prueba",
  "body": "Contenido del mensaje"
}
```

**Response (200)**

```json
{ "success": true, "message": "Email enviado correctamente" }
```

**Errores (JSON uniforme)**

```json
{ "success": false, "message": "Error enviando email: Authentication failed" }
```

> El **handshake TLS fallido (mTLS)** ocurre antes de llegar al controller; en ese caso **no hay JSON** (falla de transporte).

---

## 🧠 Manejo global de errores

`@RestControllerAdvice` captura excepciones y responde con un formato uniforme:

* `EmailSendException` → `500` con mensaje detallado.
* `Exception` genérica → `500` con mensaje estándar.

*(Opcional)* Estructura enriquecida de error:

```json
{
  "success": false,
  "code": "SMTP_AUTH_FAILED",
  "message": "Authentication failed",
  "path": "/api/email/send",
  "timestamp": "2025-08-19T10:35:00Z"
}
```

---

## 🛠️ Ejecución local

```bash
# Compilar y ejecutar\./mvnw spring-boot:run

# Probar con curl
curl -X POST http://localhost:8080/api/email/send \
  -H "Content-Type: application/json" \
  -d '{"to":"destinatario@gmail.com","subject":"Hola","body":"Mensaje de prueba"}'
```

---

## 🐳 Docker (opcional)

**Dockerfile** (ejemplo multi-stage)

```dockerfile
# ===== Build =====
FROM eclipse-temurin:17-jdk AS build
WORKDIR /app
COPY . .
RUN ./mvnw -q -DskipTests clean package

# ===== Run =====
FROM eclipse-temurin:17-jre
WORKDIR /app
COPY --from=build /app/target/sendemail-*.jar app.jar

# Usa variables de entorno en runtime
ENV SERVER_PORT=8080
EXPOSE 8080
ENTRYPOINT ["java","-jar","/app/app.jar"]
```

**.dockerignore**

```
.git
.target
.cert
certs/
.env
```

**Build & Run**

```bash
docker build -t sender-email:latest .

docker run --env-file .env -p 8080:8080 sender-email:latest
```

---

## ✉️ Desarrollo local sin cuotas (MailHog opcional)

Para evitar límites de Gmail en desarrollo, puedes utilizar **MailHog**:

**docker-compose.mailhog.yml**

```yaml
services:
  mailhog:
    image: mailhog/mailhog:latest
    ports:
      - "1025:1025"   # SMTP
      - "8025:8025"   # UI
```

**application-dev.properties**

```properties
spring.mail.host=localhost
spring.mail.port=1025
spring.mail.username=
spring.mail.password=
spring.mail.properties.mail.smtp.auth=false
spring.mail.properties.mail.smtp.starttls.enable=false
```

UI: `http://localhost:8025` (ver correos capturados).

---

## 🔒 mTLS entre Gateway y Email Service (recomendado)

**Objetivo:** El Email Service solo acepta conexiones del Gateway (o de quien tenga un cert cliente válido). El Gateway es público sin mTLS entrante, pero habla con mTLS hacia el Email Service.

### Email Service (`application.properties`)

```properties
server.port=8443
server.ssl.enabled=true

# Keystore del SERVIDOR (cert+llave)
server.ssl.key-store=classpath:certs/email-server.p12
server.ssl.key-store-type=PKCS12
server.ssl.key-store-password=changeit
server.ssl.key-alias=email-server

# Exigir cert de CLIENTE (mTLS)
server.ssl.client-auth=need

# Truststore con la CA que firmó el cert CLIENTE del Gateway
server.ssl.trust-store=classpath:certs/email-truststore.p12
server.ssl.trust-store-type=PKCS12
server.ssl.trust-store-password=changeit
```

### Spring Cloud Gateway (`application.yml`)

```yaml
server:
  port: 8443
  ssl:
    enabled: true
    key-store: classpath:certs/gateway-server.p12
    key-store-type: PKCS12
    key-store-password: changeit
    client-auth: none   # público sin mTLS entrante

spring:
  cloud:
    gateway:
      routes:
        - id: email-service
          uri: https://email-svc.local:8443
          predicates:
            - Path=/api/email/**
      httpclient:
        ssl:
          # mTLS del Gateway -> Email Service
          key-store: classpath:certs/gateway-client.p12
          key-store-type: PKCS12
          key-store-password: changeit
          trust-store: classpath:certs/upstream-truststore.p12
          trust-store-type: PKCS12
          trust-store-password: changeit
          useInsecureTrustManager: false
```

### Generación de certificados (guía rápida)

```bash
# Servidor (keystore PKCS12)
keytool -genkeypair -alias email-server -keyalg RSA -keysize 2048 \
  -dname "CN=email-svc.local, OU=IT, O=Acme, L=SCL, ST=RM, C=CL" \
  -storetype PKCS12 -keystore email-server.p12 -storepass changeit -keypass changeit

# Cliente Gateway (keystore PKCS12)
keytool -genkeypair -alias gateway-client -keyalg RSA -keysize 2048 \
  -dname "CN=gateway, OU=IT, O=Acme, L=SCL, ST=RM, C=CL" \
  -storetype PKCS12 -keystore gateway-client.p12 -storepass changeit -keypass changeit

# (Opcional) Exportar cert público para truststores
keytool -export -alias gateway-client -keystore gateway-client.p12 -storepass changeit -rfc -file gateway-client.crt
keytool -importcert -alias gateway-client -file gateway-client.crt -keystore email-truststore.p12 -storepass changeit -storetype PKCS12 -noprompt
```

> No subas `certs/*.p12` al repo. Móntalos como **Secrets** o **volúmenes** en despliegue.

---

## 🔑 OAuth2 en Gateway (PKCE)

* El Gateway expone `/oauth2/authorize` con **PKCE** (Auth Code + Proof Key).
* El Email Service **no** es un resource server obligatorio, pero puede serlo si validas JWT en backend.

**Habilitar Resource Server (opcional)**

```xml
<!-- pom.xml -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
```

```properties
# Validación de JWT vía JWK
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://issuer.example.com/.well-known/jwks.json
```

---

## 🩺 Observabilidad

**Actuator** (estado y métricas):

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

```properties
management.endpoints.web.exposure.include=health,info,prometheus
management.endpoint.health.probes.enabled=true
```

* **/actuator/health** → liveness/readiness
* **/actuator/prometheus** → scrap por Prometheus (si se requiere)

**Logging**: usa `logback-spring.xml` con niveles por paquete y MDC para trazabilidad (correlation-id).

---

## 🧪 Pruebas

* **SMTP**: verifica App Password y `spring.mail.username`.
* **Gateway público**: si activas OAuth2, prueba que `/api/email/send` rechace sin token.
* **mTLS**: llamada directa al Email Service sin cert cliente → handshake falla.
* **Postman**: para mTLS, carga el `client.p12` en la request.

---

## 🧯 Troubleshooting

**Authentication failed (535 5.7.8 BadCredentials)**

* App Password incorrecta / con espacios.
* `spring.mail.username` no corresponde a la cuenta de la App Password.
* 2FA no activado → App Password inválida.

**Handshake TLS falla**

* Cert cliente no firmado por la CA del truststore del servidor.
* Falta **SAN** en el cert del servidor (coincidir host).
* Password/rutas de keystore/truststore incorrectas.

**No obtengo JSON de error**

* Si falla TLS, el request no llega al controller (no aplica `@ControllerAdvice`).

---

## 📦 Build & Deploy

```bash
# Build
./mvnw clean package

# Ejecutar JAR
java -jar target/sendemail-0.0.1-SNAPSHOT.jar
```

**Producción**

* Secretos en variables de entorno o **Vault**.
* Montar keystores/truststores como **Secrets**.
* Configurar **readiness/liveness** si orquestas en K8s.

---

## 📏 Límites de Gmail (referencia)

* Envíos diarios (cuenta personal): \~500 destinatarios/día.
* Destinatarios por correo: hasta 100 (To+Cc+Bcc).
* Tamaño máx. mensaje: **25 MB**.

Para volumen alto, evaluar **Google Workspace** o servicios de envío transaccional (SES/SendGrid/Mailgun).

---

## 📄 Licencia

Uso interno.
